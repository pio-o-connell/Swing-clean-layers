1. Explicit mapping of your existing classes into the final structure

I’ll map only what you actually have, not imaginary “clean” classes.

warehouse.domain (pure model)

These already exist — they mostly just move package.

Company

Item

history

User

Index

They stay almost unchanged.
No JDBC.
No Swing.
Serializable is fine.

warehouse.repository (persistence)

Your current “logic-heavy” classes mostly land here.

Databases
→ becomes CompanyRepository / WarehouseRepository
Purpose: load DB into memory, initialise schema, test data

DatabaseBackup
→ BackupRepository
Purpose: write in-memory state to backup database

DatabaseRestore
→ RestoreRepository
Purpose: read backup database into domain objects

Serialized
→ FileStateRepository
Purpose: save / restore in-memory state to file

All JDBC, SQL, file IO stays here.

Annotation: @Repository

warehouse.service (use cases)

These are mostly new, but thin at first.

They wrap existing repository behaviour.

InventoryService
Uses: CompanyRepository
Purpose: core inventory operations

BackupService
Uses: BackupRepository
Purpose: “Backup warehouse”

RestoreService
Uses: RestoreRepository
Purpose: “Restore warehouse”

ReportService
Uses: GenerateReport
Purpose: reporting logic

GenerateReport technically straddles domain/service — it belongs here because it’s a use case, not persistence.

Annotation: @Service

warehouse.controller (application controllers)

These are new but simple.

They replace direct calls from Swing / Servlet into logic.

InventoryController
→ calls InventoryService

BackupController
→ calls BackupService

RestoreController
→ calls RestoreService

ReportController
→ calls ReportService

Annotation: @Component

No SQL.
No Swing.

warehouse.ui.swing

These stay UI-only.

maindriver
→ becomes SwingBootstrap (eventually)

Mainframe

Dialogs, tables, buttons

Swing now talks only to controllers.

warehouse.ui.servlet

Already exists or planned.

WarehouseServlet

LoginServlet

BackupServlet

Servlets call controllers, not services directly.

warehouse.infrastructure (manual DI)

This is new and crucial.

ApplicationBootstrap

ConnectionFactory

RepositoryFactory (optional)

This replaces Spring.

2. Bootstrap wiring design (this is the heart of it)

This answers:
“Who creates what?”
“Who injects what?”
“Where does the app actually start?”

Step 1: Create infrastructure objects

Create JDBC Connection

Create shared in-memory state (ArrayList<Company>)

This happens once.

Step 2: Create repositories

Repositories receive infrastructure dependencies.

CompanyRepository(connection, companyList)

BackupRepository(connection)

RestoreRepository(connection)

FileStateRepository()

No repository creates its own connection.

Step 3: Create services

Services receive repositories.

InventoryService(companyRepository)

BackupService(backupRepository)

RestoreService(restoreRepository)

ReportService(companyRepository)

This is where business logic lives.

Step 4: Create controllers

Controllers receive services.

InventoryController(inventoryService)

BackupController(backupService)

RestoreController(restoreService)

ReportController(reportService)

Controllers are thin.

Step 5: Inject controllers into UI

Mainframe(inventoryController, backupController, reportController)

Swing no longer knows anything else.

Step 6: Servlets reuse the same controllers

WarehouseServlet(inventoryController)

BackupServlet(backupController)

Same core, different entry points.

3. Where maindriver ends up

Your current maindriver is doing everything:

DB init

Threading

UI launch

Logic calls

In the final design:

ApplicationBootstrap
→ builds object graph

SwingBootstrap
→ launches UI using controllers

main() becomes ~10 lines.

4. What this gives you (important)

Swing and Servlet share the same business core

No framework lock-in

Annotations document intent

Manual DI makes everything visible

You can add Spring later in one weekend

5. What to do next (concrete)

Your best next move is one class only:

Refactor DatabaseBackup into:

BackupRepository

BackupService

BackupController

Do not touch UI yet.

When you want, say:

“Walk DatabaseBackup through the layers”

And we’ll do it cleanly, step by step.

You are doing real architecture work here — this is exactly how legacy systems are professionally modernised.