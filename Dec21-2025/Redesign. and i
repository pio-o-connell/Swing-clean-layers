Architectural Refactoring to a Layered Architecture

Layered Architecture with Annotation-Driven Semantics (without a framework)

This is the same refactor path used when:

Legacy Swing apps evolve into web-backed systems

Desktop apps gain REST APIs

Monoliths prepare for microservices


We are reorganizing  application into distinct layers where each layer has a specific responsibility:

| Layer                               | Responsibility                         | Example Classes                                                             |
| ----------------------------------- | -------------------------------------- | --------------------------------------------------------------------------- |
| **@Repository**                     | Database access                        | `CompanyRepository`, `ItemRepository`, `HistoryRepository`                  |
| **@Service**                        | Business logic / transactions          | `CompanyService`, `ItemService`, `HistoryService`                           |
| **@Component / Servlet Controller** | Expose endpoints, handle HTTP requests | `WarehouseServlet` or multiple servlets for items, history, companies       |
| **UI (Swing)**                      | Optional desktop client                | `DetailsPanel`, `TableWindow2` (would call Services instead of DB directly) |


Or you could keep Swing as a local client and servlets only for remote access.


The NEW layer model (top â†’ bottom)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ UI Layer (Swing / Servlet)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Controller Layer (@Component) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Service Layer (@Service)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Repository Layer (@Repository)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Infrastructure Layer          â”‚
â”‚ (JDBC, Files, Serialization)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Domain Model                  â”‚
â”‚ (Company, Item, History...)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜



1ï¸âƒ£ Domain Model (pure, already mostly correct)

What lives here
        Company
        Item
        history
        User

    Rules
        No JDBC
        No Swing
        No file IO
        No SQL

    Serializable is allowed

    âœ… Your domain objects are already mostly correct


2ï¸âƒ£ Repository Layer â€” Data access only
    Annotation          @Repository

    | Existing class         | Becomes             |
    | ---------------------- | ------------------- |
    | `Databases` (DB parts) | `CompanyRepository` |
    | `DatabaseBackup`       | `BackupRepository`  |
    | `DatabaseRestore`      | `RestoreRepository` |


3ï¸âƒ£ Service Layer â€” Business logic

    | Logic currently in                         | Moves to           |
    | ------------------------------------------ | ------------------ |
    | `Databases.insertTransactionintoDatabase`  | `InventoryService` |
    | `Databases.updateHistoryTransintoDatabase` | `HistoryService`   |
    | Quantity calculations                      | `InventoryService` |
    | Report orchestration                       | `ReportService`    |

4ï¸âƒ£ Controller Layer â€” Application boundary

    @Component
        This is NOT Swing and NOT servlet

        Your app has two controller types
    ğŸŸ¦ Desktop Controller

    ğŸŸ© Servlet Controller

    Both call the same services.

5ï¸âƒ£ UI Layer â€” Presentation only
        Swing classes:

                Mainframe

                DetailsPanel

                Tables, buttons, labels

                Rules

                âŒ No SQL
                âŒ No JDBC
                âŒ No repositories
                âŒ No business rules

                âœ… Collect user input
                âœ… Display results
                âœ… Call controller methods

6ï¸âƒ£ Infrastructure Layer â€” technical plumbing
        What lives here

            JDBC connections

            Serialization

            File IO

            Configuration

        Your classes here
            Class	    Role
            Serialized	File persistence
            JDBC setup	Connection factory

7ï¸âƒ£ Annotations â€” what they mean without Spring
        They are semantic markers, not behavior.

    They give you:

        Architectural clarity

        Searchability

        Enforcement by convention

        Optional future framework compatibility

    They do NOT:

        Inject dependencies

        Create objects

        Manage transactions

    You wire manually: